# Making Perfect Software 

## The masterful art of the seemingly impossible

### Authors: [Jason Grant, MSc](http://jasongrant.in)

After 20 years of software design and engineering practice, I realised it's about time I too start writing about making software. 

I decided to document what I know for all those who want to make great software. 

For those that want to create software tools which are (at the very least) close to perfection. 

For those that are aiming for optimal results, with minimum effort. 

For those who want to enjoy software engineering (again).

This always struck me as the wisest way to approach any activity. 

Utilise energy as effectively as possible, while creating the most impactful results in the process. 

This is especially true of software projects, where energy gets used in massive quanities.

Vast amounts of energy get wasted by badly written software. 

Far from optimal software gets created by practitioners who do not follow principles and best practices outlined in this book. 

Software that is near perfect gets created by practitioners who **do** follow these guidelines. 

Let's get into it.

## How I got into Software Engineering

I remember the days in late 1980s, when I first started programming. 

C64 computer manual was the main form of 'Software Engineering' that was accessible to me. 

It was the beginning of exposue to computers for me. 

At the time I couldn't speak English at all. 

The way I learnt to code (largely) was by typing in other people's programmes during a computer club I attended, or by reverse engineering code knowledge from error messages from misloaded computer games. 

Within months, a bunch of us had worked out what majority of commands meants and how they were to be used. 

We soon started writing our own programmes, however purposeless they were.

It wasn't long before I started realising that knowing what has been done, how and why was somewhat more interesting than the code itself. 

This meta framework of organising code in a way that is best to work with became my obsession from the age of around 9 years old. 

The rest is, quite literally, history.

## Super short history of Software Engineering

Software Engineering has gone through a number of phases of evolution, as does everything else. 

### Phase 1: Local software 

Software was written for a single machine. 

Made on the same machine which it was to be run on. 

This in itself was success, as everything undocumented or, at best, badly documented. 

Software was written through trial and error. 

Memory was super small, machines were super large and porting code from one machine to another was virtually impossible. 

### Phase 2: Manually distributed software 

Removable memory was invented. 

Either in form of punched cards, tapes or eventually disks (such as floppy disks or Compact Discs).

As external memory became cheaper and larger, manually distributed software became possible. 

This gave rise to companies such as Microsoft, which made operating systems distributed on CDs a big businesses. 

Software updates would be delivered on yearly basis, if that. 

Each build and release was heavily tested to work as well as possible after installation from disc. 

Knowing whether the software worked on the target machines was virtually impossible. 

Internet still didn't exist for the large part. 

### Phase 3: Network distributed software 

In this phase, software is distributed over the Internet. 

People download the code and they install it on their machines. 

Software itself still runs on and for the local machine, with occassional ability to connect to the internet, for special purposes. 

Data is stored on the local machine (for the most part).

Personal profiles either don't exist or they are local to that particular user and that particular machine. 

Software gets unlocked with a licence key, which is also for a person or per machine. 

### Phase 4: Networked software 

Software is now connected to the internet and there is a notion of an online profile. 

Much of the activity of the software runs online, but local machine installed code is still necessary.

More of the data software produces is stored online or backed up online. 

Internet connection is required for the software to work (fully).

Local machine functionality is used for 'rich' functions and everything else simple is handed over the network processing. 

### Phase 5: SaaS 

The entire software is now on the web, served from the web, running from the web, storing data on the web and accessed and  updated through the web.

The user never has to worry about 'getting' the software.

The user now 'goes to' the software if and when they like it. 

All the activity, data and functionality happens on the web and nothing is ever 'lost' if the user's local machine stops working. 

Software is no longer a product, but a continuously evolving service, which the user expects to be up to date all the time and continuously improved. 

Bugs and issues are expected not to exist and User Experience is one of the main differentiating factors. 

User expects to be able to access the software seamlessly from any kind of a device and for it to be useful, usable and enjoyable to use at all times. 

User doesn't expect to have to 'learn' the software, but wants the software to 'lend' itself for easy and intuitive use without any training. 

Updates and improvements happen on regular basis and are part and parcel of the Software as a Service agreement. 

Data created and managed by the user is still owned by the user, but the company delivering SaaS solution manages it and keeps it safe, secure and conherent. 

SaaS software runs on one or more centralised cloud service providers, who provide hardware and software services that enable the cloud software to run on public or private cloud.

### Phase 6: Blockchain 

Software is now becoming decentralised or distributed. 

Digital money (cryptocurrency) is an integral part of the software capabilities.

Much of the algorithm is running on a distributed network of nodes, which are responsible for processign and validating transactions between node wallets. 

Users own the core data in their wallets on their own local devices. 

The rest of the transaction information is stored publicly on immutable Blockchain ledger, which transparently shows all (mostly financial) transactions between wallets. 

Core software is developed as open source code set which is available for everyone to inspect and part take in co-creating. 

More and more SaaS tools are becoming disrupted by DApps (Distributed Apps) where use interactions are the most valuable part of the software. 

Data becomes more important and valuable part of the software (in many cases) than the algorithm which is processing it. 

The software is much more about giving granulated control over the data back to the users and leaving it to them to manage its security on the consumer end. 

## Software Engineering is a discipline

The word 'discipline' is a powerful word. 

It means any one of the following: 

* orderly or prescribed conduct or pattern of behavior
* training that corrects, molds, or perfects the mental faculties or moral character 
* a field of study
* a rule or system of rules governing conduct or activity 

Software Engineering discripline is a fine combination of all those definitions. 

It's one of the most precise forms of art I know of. 

Precision and unambiguity are **the core building blocks** of great Software Engineering. 

Yet, there is a massive need for redability, understandability, sense making and general philosophical coherence within the whole creation.

Just like in life itself. 

As such, Software Engineering mirrors life very closely. 

For most part, humans are aiming to automate life with software.

They are biomimicring nature with machines.

This is yet another correlation between software and real life.

This is why understanding (human) nature is also very important, before we can become great software engineers. 

Almost nobody will ever tell you this in any training programme or University. 

However, as soon as you get into the work environment, you realise that the human factor plays 80%+ of the role in the success or failure of any software project. 

This is why getting humans to work together in a more disciplined way is one of the keys to successful software.

Discipline itself is built on principles, which need to be followed as closely as possible.

## Aspects of Software Engineering discipline

Many people might think that software is all about maths, machines and mechanics. 

All those are certain an important aspect of software, but they are by no means the only aspect. 

Software Engineering is made up of (at the very least) following aspects: 

1. Mechanics (the core notion behind the term 'Engineering')
2. Philosophy (overall idea of how information should be organised)
3. Psychology (how the mechanics of software work with mechanics of human minds)
4. Economics (how (energy) efficient software is compared to non-software solution)

Let's look into more details of each one of these aspects of Software Engineering.

## Philosophy 

Philosophy is 'The study of the nature, causes, or principles of reality, knowledge, or values, based on logical reasoning.' 

This definition is describing the core activities Software Engineers and Architects part take in to create software. 

Logical reasoning is very important in Software Engineering. 

The dynamics of causes and effects are at play here all the time. 

Being able to manipulate these causes and effects (in form of data and information) is what Software Engineering is all about. 

The manipulation needs to be as close to 100% predictable and testable as possible. 

This is why the formal qualification related to Software Engineering is called Computer Science. 

## Mechanics 

Software is great at automating those things which are either mechanical in nature or can be sequenced as a set of repeatable, procedural steps.

Software also works very well for clearly structured things. 

The word 'thing' is the key here. 

Things are objects which can be described with their attributes, functionalities they can perform and information they take in and put back out. 

Unless we are dealing with things, creating software will be hard or impossible.

Things 'string together' into mechanical creations, which are carefully (which I like to split up into care-fully) put together to create higher order value. 

## Psychology 

Developers create software. 

Before them, designers and software architects define software. 

All these different kinds of humans possess psychology.

The mental models they understand, work with and ultimately put into practice. 

People using software also have their own psychology.

This is why human psychology plays a massive role in Software Engineering.

Great Software Engineers don't only make software useful, usable and valuable for machines, but also make it useful, usable and easy to work with for humans, respecting general principles of psychology.

## Economics 

The main reason why humans started building software is to automate repetative tasks. 

Automation leads to better economic situation, as it leads to cheaper way to run bigger operations. 

As civilisation becomes more complex, there is an increasing need for software (automation) to enable economic prosperity to continue, without overloading the economic circuits in the process.

Without software, vast majority of modern day infrastructure could not run at all.

With software, it can not only run, but be economically viable in the long(er) term.

When you are engineering software, you need to remember the economics of your choices, as, sooner or later, they will come to surface to either enable or disable future life of that software.

## Principle 1: Caring

'What's 'caring' got to do with Software Engineering?' you might ask. 

The answer is simple. 

Everything! 

I've come across **so many** people in my professional experience who simply don't care about software. 

They treat it as a chore. 

As a kind of a pain in the backside, which is best done as quickly as possible and forgotten about. 

I've never found this to be possible in software projects. 

As soon as developers get committed to a software project, chances are, that software project will linger around for years and years to come. 

No company commits to developing software they don't care to make. 

Therefor the principle of 'caring' is essential. 

The software you are creating needs to be treated as an artistic masterpiece. 

Most artists are engineers in disguise. 

They are making things using the same mathematical principles and rules of aesthetics as engineers do. 

Any masterpiece has a long term impact and 'stays fresh' for a long time to come. 

This is the case with perfect software too. 

If you don't care about what you are coding, you should probably not be a software engineer. 

If you don't care, sooner or later you or others in your team are going to start 'suffering your code'. 

That's a terrible place for everyone in the team to be at. 

More importantly, carelessly written code adds overhead for future upgrades and maintenance and simply costs money and time to manage. 

Perfect software, however, over time keeps producing higher and higher ROI by being maintanable at fraction of a cost to comparable other software. 

Most cowboy developers don't even begin to understand this and, as such, will come into teams, quickly 'pollute' the codebase with junk code and before you even know your software is impossible to work with. 

If every member within the team does not deeply care about what they are making, your software project is already in potentially very deep trouble. 

## Principle 2: Precision

Precision is a rarely discussed idea in today's world. 

Yet, the reason why Swiss watches have been valued over decades is precisely their precision. 

Any kind of an instrument is valuable because it is precise. 

A ruler needs to precisely help you measure and mark up a distance between two points, as well as draw a straight line between those two points. 

A weighing scale need to tell you how much weight is on it, as precisely as possible. 

A car autopilot needs to precisely get the car through a route without bumping into things and causing damage. 

A blockchain ledger needs to precisely record a set of entries within it. 

Without precision, no tool or instrument is valuable. 

Software, beyond anything else, needs to be as precisely defined, programmed and run as possible. 

Imprecisions mount up to great problems and troubles down the road. 

We typically refer to them as 'bugs', but the word 'imprecisions' is perhaps a much better description of what 'bugs' actually are. 

The more precise you get your software and words to be, the more valuable it will be in the long run.

## Principle 3: Atomicity

An atom is an irreducible part of whole. 

The smallest possible level of a component which contributes to the overall working of the system. 

Every perfect system is made from atomic units.

These atomic units can be (in theory) oriented around any kind of a core focus: objects, functions, aspects, etc. 

Many people prefer object oriented approach, yet that is really just one (commonly adopted) approach to building software. 

It's not 'better' per se, just, perhaps, more commonly understood, even though most people, when pressed hard enough, will admit they don't really know object-oriented programming well enough.

Either way, atomicity is the key principle here. 

Working with, to start off with, irreducible atomic units within software is essential. 

Those atomic units must be fully tested, working, sense making and perfectly created. 

They are going to get reused many, many times and, if they don't work, they will break everyting else. 

On the other hand, if those atomic units work perfectly, they are 'lending perfection' to higher order components (molecules and compounds) in the software.

Through this approach, software has exponentially higher chance of being perfect in bigger form than with any other approach. 

## Principle 4: Understanding

## Principle 5: Architecture 

## Principle 6: Interface 

## Principle 7: Testability 

## Principle 8: Clarity 

## Principle 9: Semanticity 

## Principle 10: Optimality 